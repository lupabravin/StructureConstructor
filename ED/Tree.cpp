extern "C" {
#include "Tree.h"
#include <stdio.h>  
#include <stdlib.h>
#include <string.h>
}



/* A estrutura da árvore é representada por um ponteiro
para o nó raiz. Com esse ponteiro, temos acesso aos
demais nós. */

/* Função que cria uma árvore */
Tree* createTree()
{
	/* Uma árvore é representada pelo endereço do nó raiz,
	essa função cria uma árvore com nenhum elemento,
	ou seja, cria uma árvore vazia, por isso retorna NULL. */
	return NULL;
}

/* Função que verifica se uma árvore é vazia */
int treeIsEmpty(Tree* t)
{
	/* Retorna 1 se a árvore for vazia e 0 caso contrário */
	return t == NULL;

}

/* Função que mostra a informação da árvore */
void showTree(Tree* t)
{
	/* Essa função imprime os elementos de forma recursiva */

	printf("<"); /* notação para organizar na hora de mostrar os elementos */
	if (!treeIsEmpty(t)) /* se a árvore não for vazia... */
	{
		/* Mostra os elementos em pré-ordem */
		printf("%d ", t->num); /* mostra a raiz */
		showTree(t->sae); /* mostra a sae (subárvore à esquerda) */
		showTree(t->sad); /* mostra a sad (subárvore à direita) */
	}
	printf(">"); /* notação para organizar na hora de mostrar os elementos */
}

/* Função que insere um dado na árvore */
void insertTree(Tree** t, int num)
{
	/* Essa função insere os elementos de forma recursiva */
	if (*t == NULL)
	{
		*t = (Tree*)malloc(sizeof(Tree)); /* Aloca memória para a estrutura */
		(*t)->sae = NULL; /* Subárvore à esquerda é NULL */
		(*t)->sad = NULL; /* Subárvore à direita é NULL */
		(*t)->num = num; /* Armazena a informação */
	}
	else {
		if (num < (*t)->num) /* Se o número for menor então vai pra esquerda */
		{
			/* Percorre pela subárvore à esquerda */
			insertTree(&(*t)->sae, num);
		}
		if (num >(*t)->num) /* Se o número for maior então vai pra direita */
		{
			/* Percorre pela subárvore à direita */
			insertTree(&(*t)->sad, num);
		}
	}
}

/* Função que verifica se um elemento pertence ou não à árvore */
int isInTree(Tree* t, int num) {

	if (treeIsEmpty(t)) { /* Se a árvore estiver vazia, então retorna 0 */
		return 0;
	}

	/* O operador lógico || interrompe a busca quando o elemento for encontrado */
	return t->num == num || isInTree(t->sae, num) || isInTree(t->sad, num);
}

